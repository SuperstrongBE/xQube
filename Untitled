(function(self, $) {
  function remove(arr, item) {
    for (var i = arr.length; i--;) {
      if (arr[i] === item) {
        arr.splice(i, 1);
      }
    }
  }
  self.setSmooth = function(arg) {
    grid = !arg;
    smoothRender = arg ? 2 : .4
  };
  self.setHideChat = function(arg) {
    hideChat = arg;
    if (arg) {
      $("#chat_textbox").hide();
    } else {
      $("#chat_textbox").show();
    }
  };
  self.setBruh = function(d) {
    debug = d;
    if (d) {
      bruh = [];
      for (var i = 0; i < 10; i++) {
        bruh.push(new Audio("bruh.mp3"));
      }
    }
  };
  self.setBubble = function(d) {
    bubblemode = d;
  };
  self.setBlocked = function(d) {
    blocker = d;
  };
  self.setMap = function(d) {
    map = !d;
  }
  self.setSpray = function(d) {
    spray = !d;
  };
  self.setDest = function(d) {
    dest = d;
    next();
  };
  self.block = function(id) {
    blocklist.push(id);
  };
  self.unblock = function(id) {
    remove(blocklist, id);
  };
  self.showPlayerMenu = function(id, name) {
    $("#player").show();
    $("#playerName").text(name);
    if (blocklist.indexOf(id) > -1) {
      $("#btnBlock").text("Unblock");
    } else {
      $("#btnBlock").text("Block");
    }
    $("#btnBlock").click(function() {
      if (blocklist.indexOf(id) > -1) {
        unblock(id);
      } else {
        block(id);
      }
      if (blocklist.indexOf(id) > -1) {
        $("#btnBlock").text("Unblock");
      } else {
        $("#btnBlock").text("Block");
      }
      $("#btnBlock").blur();
    });
    if (SETTINGS.ADMIN != "") {
      $("#btnMute").click(function() {
        sendChat("/mute " + id + " " + parseInt($("#txtMute").val()));
      });
      $("#playerAdmin").show();
    } else {
      $("#playerAdmin").hide();
    }
  }
  self.setMouse = function(d) {
    mouseLine = d;
  };
  var touchX, touchY, touchable = 'createTouch' in document,
    touches = [];
  var leftTouchID = -1,
    leftTouchPos = new Vector2(0, 0),
    leftTouchStartPos = new Vector2(0, 0),
    leftVector = new Vector2(0, 0);
  var bubble = new Image;
  bubble.src = "./css/img/bubble.png?v=1";
  var splitIcon = new Image;
  splitIcon.src = "./css/img/split.png?v=15";
  var ejectIcon = new Image;
  ejectIcon.src = "./css/img/eject.png?v=15";
  var bruh = [],
    bubblemode = false,
    isActive = true,
    wPressed = false,
    spam = false,
    spray = true,
    dest = "",
    attr = false,
    grid = true,
    map = true,
    blocklist = [],
    mouseLine = false,
    newProtocol = false,
    blocker = false;
  var isMobile = "ontouchstart" in self && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  window.onfocus = function() {
    isActive = true;
  };
  window.onblur = function() {
    isActive = false;
  };
  $(window).bind('beforeunload', function(e) {
    var confirmationMessage = 'Are you sure you want to leave? ' + 'You will lose all your mass!';
    (e || window.event).returnValue = confirmationMessage;
    if (playerCells.length > 0) return confirmationMessage;
    return undefined;
  });

  function init() {
    ma = true;
    document.getElementById("canvas").focus();
    var isTyping = false;
    mainCanvas = nCanvas = document.getElementById("canvas");
    ctx = mainCanvas.getContext("2d");
    var chat = document.getElementById("chat");
    var restart = "";
    window.onmousemove = function(event) {
      rawMouseX = event.clientX;
      rawMouseY = event.clientY;
      mouseCoordinateChange()
    };
    if (touchable) {
      mainCanvas.addEventListener('touchstart', onTouchStart, false);
      mainCanvas.addEventListener('touchmove', onTouchMove, false);
      mainCanvas.addEventListener('touchend', onTouchEnd, false);
    }
    mainCanvas.onmouseup = function() {};
    if (/firefox/i.test(navigator.userAgent)) {
      mainCanvas.addEventListener("DOMMouseScroll", handleWheel, false);
      chat.addEventListener("DOMMouseScroll", handleWheel, false);
    } else {
      mainCanvas.onmousewheel = handleWheel;
      chat.onmousewheel = handleWheel;
    }
    mainCanvas.onfocus = function() {
      isTyping = false;
    };
    document.getElementById("chat_textbox").onblur = function() {
      isTyping = false;
    };
    document.getElementById("chat_textbox").onfocus = function() {
      isTyping = true;
    };
    if (SETTINGS.FORCE == "") {
      function stolen() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }
      if (self != top && !(document.referrer.toLowerCase().indexOf("germs.io") > -1) || stolen()) {
        window.top.location.href = "http://germs.io";
      }
    }
    var isAndroid = /(android)/i.test(navigator.userAgent);
    if (isAndroid) {
      window.open("market://details?id=io.germs.mobile", "_system");
      setTimeout(function() {
        window.location.href = "https://play.google.com/store/apps/details?id=io.germs.mobile";
      }, 500);
    }
    var spacePressed = false,
      qPressed = false;
    const SPACE = 32,
      Q = 81,
      W = 87,
      ESC = 27,
      BKSP = 8;
    window.onkeydown = function(event) {
      var doPrevent = false;
      switch (event.keyCode) {
        case SPACE:
          if ((!spacePressed) && (!isTyping)) {
            sendMouseMove();
            sendUint8(17);
            spacePressed = true;
            if (!debug) break;
            var played = false;
            for (var i = 0; i < 10; i++) {
              var sound = bruh[i];
              if (!isPlaying(sound) && !played) {
                played = true;
                sound.play();
              }
            }
          }
          break;
        case Q:
          if ((!qPressed) && (!isTyping)) {
            sendUint8(18);
            qPressed = true;
          }
          break;
        case W:
          if ((!wPressed) && (!isTyping)) {
            sendUint8(21);
            wPressed = true;
            if (spray == true) {
              setTimeout(function() {
                spam = true;
              }, 50);
            } else {
              spam = false;
            }
          }
          break;
        case ESC:
          showOverlays(true);
          self.isSpectating = false;
          break;
        case BKSP:
          var d = event.srcElement || event.target;
          if ((d.tagName.toUpperCase() === 'INPUT' && (d.type.toUpperCase() === 'TEXT' || d.type.toUpperCase() === 'PASSWORD' || d.type.toUpperCase() === 'FILE' || d.type.toUpperCase() === 'SEARCH' || d.type.toUpperCase() === 'EMAIL' || d.type.toUpperCase() === 'NUMBER' || d.type.toUpperCase() === 'DATE')) || d.tagName.toUpperCase() === 'TEXTAREA') {
            doPrevent = d.readOnly || d.disabled;
          } else {
            doPrevent = true;
          }
          break;
      }
      if (doPrevent) {
        event.preventDefault();
      }
    };
    window.onkeyup = function(event) {
      switch (event.keyCode) {
        case 32:
          spacePressed = false;
          break;
        case 87:
          wPressed = false;
          spam = false;
          setTimeout(function() {
            spam = false;
          }, 51);
          break;
        case 81:
          if (qPressed) {
            sendUint8(19);
            qPressed = false;
          }
          break;
      }
    };
    window.onblur = function() {
      sendUint8(19);
      wPressed = qPressed = spacePressed = false
    };
    window.onresize = canvasResize;
    canvasResize();
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(redrawGameScene);
    } else {
      setInterval(drawGameScene, 30);
    }
    mouseInterval = setInterval(sendMouseMove, 50);
    null == ws && w && showConnecting();
    $("#overlays").show();
    if (window.location.hash && SETTINGS.FORCE == "") {
      $("#party").show();
      $("#partyJoin").show();
      $("#partyEnter").show();
      $("#partyCreate").hide();
      $("#partySelect").hide();
      $("#partyEnterToken").val(window.location.hash);
      setPartyServer(window.location.hash);
    } else {
      next();
    }
    $("#playBtn").click(function() {
      setNick(document.getElementById('nick').value);
      return false;
    });
    if (isMobile) {
      setSmooth(true);
    }
  }

  function onTouchStart(e) {
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if ((leftTouchID < 0) && (touch.clientX < canvasWidth / 2)) {
        leftTouchID = touch.identifier;
        leftTouchStartPos.reset(touch.clientX, touch.clientY);
        leftTouchPos.copyFrom(leftTouchStartPos);
        leftVector.reset(0, 0);
      }
      var size = ~~(canvasWidth / 7);
      if ((touch.clientX > canvasWidth - size) && (touch.clientY > canvasHeight - size)) {
        sendMouseMove();
        sendUint8(17);
      }
      if ((touch.clientX > canvasWidth - size) && (touch.clientY > canvasHeight - 2 * size - 10) && (touch.clientY < canvasHeight - size - 10)) {
        sendMouseMove();
        sendUint8(21);
      }
    }
    touches = e.touches;
  }

  function onTouchMove(e) {
    e.preventDefault();
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if (leftTouchID == touch.identifier) {
        leftTouchPos.reset(touch.clientX, touch.clientY);
        leftVector.copyFrom(leftTouchPos);
        leftVector.minusEq(leftTouchStartPos);
        rawMouseX = leftVector.x * 3 + canvasWidth / 2;
        rawMouseY = leftVector.y * 3 + canvasHeight / 2;
        mouseCoordinateChange();
        sendMouseMove();
      }
    }
    touches = e.touches;
  }

  function onTouchEnd(e) {
    touches = e.touches;
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if (leftTouchID == touch.identifier) {
        leftTouchID = -1;
        leftVector.reset(0, 0);
        break;
      }
    }
  }

  function handleWheel(event) {
    zoom *= Math.pow(.9, event.wheelDelta / -120 || event.detail || 0);
    (.05) > zoom && (zoom = (.05));
    zoom > 4 / viewZoom && (zoom = 4 / viewZoom)
  }

  function buildQTree() {
    if (.4 > viewZoom) qTree = null;
    else {
      var a = Number.POSITIVE_INFINITY,
        b = Number.POSITIVE_INFINITY,
        c = Number.NEGATIVE_INFINITY,
        d = Number.NEGATIVE_INFINITY,
        e = 0;
      for (var i = 0; i < nodelist.length; i++) {
        var node = nodelist[i];
        if (node.shouldRender() && !node.prepareData && 20 < node.size * viewZoom) {
          e = Math.max(node.size, e);
          a = Math.min(node.x, a);
          b = Math.min(node.y, b);
          c = Math.max(node.x, c);
          d = Math.max(node.y, d);
        }
      }
      qTree = Quad.init({
        minX: a - (e + 100),
        minY: b - (e + 100),
        maxX: c + (e + 100),
        maxY: d + (e + 100),
        maxChildren: 1,
        maxDepth: 3
      });
      for (i = 0; i < nodelist.length; i++) {
        node = nodelist[i];
        if (node.shouldRender() && !(20 >= node.size * viewZoom)) {
          for (a = 0; a < node.points.length; ++a) {
            b = node.points[a].x;
            c = node.points[a].y;
            b < nodeX - canvasWidth / 2 / viewZoom || c < nodeY - canvasHeight / 2 / viewZoom || b > nodeX + canvasWidth / 2 / viewZoom || c > nodeY + canvasHeight / 2 / viewZoom || qTree.insert(node.points[a]);
          }
        }
      }
    }
  }

  function mouseCoordinateChange() {
    X = (rawMouseX - canvasWidth / 2) / viewZoom + cameraX;
    Y = (rawMouseY - canvasHeight / 2) / viewZoom + cameraY;
    if (mouseLine) {
      drawLine = true;
      drawLineX = X;
      drawLineY = Y;
      lineX = X;
      lineY = Y;
    } else {
      drawLine = false;
    }
  }

  function hideOverlays() {
    hasOverlay = false;
    $("#overlays").fadeOut();
    $(".chat").fadeIn();
    $(".skinList li").slice(1);
  }

  function updateStats(a, b) {
    var c = -1 != nodesOnScreen.indexOf(a.id),
      d = -1 != nodesOnScreen.indexOf(b.id),
      e = 30 > b.size;
    c && e && ++foodEaten;
    e || !c || d || ++cellsEaten;
  }

  function secondsToString(seconds) {
    if (seconds < 1) {
      return "0:00";
    } else {
      var minutes = Math.floor(seconds / 60);
      var seconds = seconds - minutes * 60;
      return minutes + ":" + ("0" + seconds).slice(-2);
    }
  }

  function showOverlays(arg) {
    $(".stats-time-alive").text(timeToString((Date.now() - timeAlive) / 1E3));
    $(".stats-leaderboard-time").text(secondsToString(timeLeader - 1));
    $(".stats-food-eaten").text(foodEaten);
    $(".stats-top-position").text(topPosition > 0 ? topPosition : ":(");
    $(".stats-cells-eaten").text(cellsEaten);
    $(".stats-highest-mass").text(~~(userScore / 100));
    if (arg == false) {
      $("#login-tile").hide('slow');
      $("#stats").fadeIn('slow');
      $("#ad").hide();
      $("#ad-dead").show();
      $("#login").fadeIn('slow');
    } else {
      $('#stats').hide();
      $("#ad").show();
      $("#ad-dead").hide();
      $('#login-tile').fadeIn();
      $('#login').fadeIn();
    }
    if (!blocker) factorem.refreshAds([2], true);
    hasOverlay = true;
    userNickName = null;
    $("#overlays").fadeIn(arg ? 200 : 3500);
    $(".chat").hide();
  }

  function h2(b) {
    var bytes = [],
      str;
    for (var i = 0; i < b.length - 1; i += 2) bytes.push(parseInt(b.substr(i, 2), 16));
    return String.fromCharCode.apply(String, bytes);
  }
  var current = "";

  function next(reconnect, party) {
    if (dest.toLowerCase().indexOf("party") > -1 && reconnect != false && SETTINGS.FORCE == "") {
      dest = name = current = "Party";
      $("#party").fadeIn('fast');
      $("#partySelect").fadeIn('fast');
      $("#partyCreate").hide();
      $("#partyJoin").hide();
      $("#gamemode").html(name);
    } else if (typeof party === 'object' && SETTINGS.FORCE == "") {
      var port = party[0];
      var players = party[1];
      dest = name = current = "Party";
      open("ws://party.germs.io:" + port + "/?ip=" + SETTINGS.IP + "&key=" + SETTINGS.API);
      $("#gamemode").html(name);
    } else if (dest.toLowerCase().indexOf("leap") > -1) {
      window.location.href = "http://micos.io?leap";
    } else {
      if (reconnect != true) {
        if ((SETTINGS.FORCE != "" && SETTINGS.FORCE == current) || (dest != "" && dest == current)) return;
      }
      $("#partySelect").fadeIn('fast');
      $("#partyCreate").hide();
      $("#partyJoin").hide();
      $("#partyDone").hide();
      $("#partyEnter").show();
      if (SETTINGS.FORCE == "") history.pushState("", document.title, window.location.pathname);
      $("#count").html("Connecting...");
      $("#count").show();
      if (SETTINGS.FORCE != "") {
        dest = current = "Custom";
        open("ws://" + SETTINGS.FORCE + "/?ip=" + SETTINGS.IP + "&key=" + SETTINGS.API, function() {
          updatePlayerCount(SETTINGS.FORCE.split(":")[0] + ":443", dest);
        });
        $("#gamemode").html(dest);
        console.log("Loading " + dest + "...");
      } else {
        $.get("./" + "server.php?" + dest, function(data, status) {
          var result = JSON.parse(h2(data));
          var name = result.name;
          var server = result.server;
          var port = result.port;
          var stats = result.stats;
          dest = name;
          console.log("Loading " + dest + "...");
          open("ws://" + server + ":" + port + "/?ip=" + SETTINGS.IP + "&key=" + SETTINGS.API, function() {
            updatePlayerCount(server + ":" + stats, name);
          });
          $("#gamemode").html(((name.indexOf("-") > -1) ? (name.split('-')[1] + " " + name.split('-')[0]) : name));
        });
      }
    }
    if ($("#party").is(':visible')) {
      $("#settings").css("margin-top", "160px");
    } else {
      $("#settings").css("margin-top", "0px");
    }
    $("#chat-rows").html("");
  }
  var loading = false;

  function updatePlayerCount(url, dest) {
    if (!loading && SETTINGS.FORCE == "") {}
  }

  function showConnecting() {
    if (ma && w) {
      showOverlays();
      next(true);
    }
  }

  function open(wsUrl, callback) {
    if (ws) {
      ws.onopen = null;
      ws.onmessage = null;
      ws.onclose = null;
      try {
        ws.close()
      } catch (b) {}
      ws = null;
    }
    restart = "";
    nodesOnScreen = [];
    playerCells = [];
    loadedSkins = [];
    nodes = {};
    nodelist = [];
    blocklist = [];
    Cells = [];
    leaderBoard = [];
    mainCanvas = teamScores = null;
    userScore = foodEaten = topPosition = cellsEaten = 0;
    follow = -1;
    lastKilled = -1;
    timeAlive = Date.now();
    timeLeader = null;
    ws = new WebSocket(wsUrl);
    ws.binaryType = "arraybuffer";
    ws.onopen = function() {
      if (callback) {
        callback();
      }
      onWsOpen();
    };
    ws.onmessage = onWsMessage;
    ws.onclose = onWsClose;
    ws.onerror = onWsClose;
  }

  function prepareData(size) {
    return new DataView(new ArrayBuffer(size))
  }

  function wsSend(dataview) {
    ws.send(dataview.buffer)
  }

  function onWsOpen() {
    delay = 100;
    _ws = ws;
    updateChatColor();
    drawGameScene();
    var msg = prepareData(5);
    msg.setUint8(0, 254);
    msg.setUint32(1, 5, true);
    wsSend(msg);
    var msg = prepareData(5);
    msg.setUint8(0, 255);
    msg.setUint32(1, parseInt(SETTINGS.HASH), true);
    wsSend(msg);
    newProtocol = true;
    sendNickName();
    if (SETTINGS.ADMIN != "") {
      sendAdmin(SETTINGS.ADMIN);
    }
    $("#connecting").hide();
    console.log("Connected to " + dest + "!");
    $("#playBtn").prop('disabled', false);
  }

  function onWsClose(e) {
    console.log("Socket closed! Code: " + e.code + " " + e.reason);
    if (e.reason == "No slots") {
      alert("Server Full! :(");
      dest = "";
      next();
    }
    setTimeout(showConnecting, delay);
    delay *= 1.5
    $("#playBtn").prop('disabled', true);
  }

  function onWsMessage(msg) {
    handleWsMessage(new DataView(msg.data))
  }

  function handleWsMessage(msg) {
    function getString() {
      var text = '',
        char;
      while ((char = msg.getUint16(offset, true)) != 0) {
        offset += 2;
        text += String.fromCharCode(char);
      }
      offset += 2;
      return text;
    }
    var offset = 0,
      setCustomLB = false;
    240 == msg.getUint8(offset) && (offset += 5);
    switch (msg.getUint8(offset++)) {
      case 254:
        var count = msg.getUint32(offset, true);
        offset += 4;
        $("#count").html(count + " Player" + ((count > 1) ? "s" : "") + " in " + ((dest.toLowerCase().indexOf("party") > -1) ? "this map" : ((dest.indexOf('-') > -1) ? dest.split('-')[1] + " " + dest.split('-')[0] : dest)) + "!");
        $("#count").show();
        current = dest;
        break;
      case 16:
        updateNodes(msg, offset);
        break;
      case 17:
        posX = msg.getFloat32(offset, true);
        offset += 4;
        posY = msg.getFloat32(offset, true);
        offset += 4;
        posSize = msg.getFloat32(offset, true);
        offset += 4;
        cameraX = posX;
        cameraY = posY;
        follow = -1;
        lastKilled = -1;
        break;
      case 20:
        playerCells = [];
        nodesOnScreen = [];
        break;
      case 21:
        lineX = msg.getInt16(offset, true);
        offset += 2;
        lineY = msg.getInt16(offset, true);
        offset += 2;
        if (!drawLine) {
          drawLine = true;
          drawLineX = lineX;
          drawLineY = lineY;
        }
        break;
      case 24:
        var end = getString();
        restart = end;
        break;
      case 32:
        nodesOnScreen.push(msg.getUint32(offset, true));
        offset += 4;
        break;
      case 48:
        setCustomLB = true;
        noRanking = true;
        break;
      case 49:
        if (!setCustomLB) {
          noRanking = false;
        }
        teamScores = null;
        var LBplayerNum = msg.getUint32(offset, true);
        offset += 4;
        leaderBoard = [];
        for (i = 0; i < LBplayerNum; ++i) {
          var position = msg.getUint32(offset, true);
          offset += 4;
          var nodeId = msg.getUint32(offset, true);
          offset += 4;
          leaderBoard.push({
            rank: position,
            id: nodeId,
            name: getString()
          })
        }
        drawLeaderBoard();
        break;
      case 50:
        teamScores = [];
        var LBteamNum = msg.getUint32(offset, true);
        offset += 4;
        for (var i = 0; i < LBteamNum; ++i) {
          teamScores.push(msg.getFloat32(offset, true));
          offset += 4;
        }
        drawLeaderBoard();
        break;
      case 64:
        leftPos = msg.getFloat64(offset, true);
        offset += 8;
        topPos = msg.getFloat64(offset, true);
        offset += 8;
        rightPos = msg.getFloat64(offset, true);
        offset += 8;
        bottomPos = msg.getFloat64(offset, true);
        offset += 8;
        posX = (rightPos + leftPos) / 2;
        posY = (bottomPos + topPos) / 2;
        posSize = 1;
        if (0 == playerCells.length) {
          nodeX = posX;
          nodeY = posY;
          viewZoom = posSize;
        }
        break;
      case 97:
        var pID = msg.getUint32(offset, true);
        offset += 4;
        $("#chat-rows font").each(function() {
          if (parseInt($(this).attr("title")) == pID) {
            $(this).closest("p").remove();
          }
        });
        break;
      case 98:
        var amount = msg.getUint8(offset++);
        for (var i = 0; i < amount; i++) {
          if ($("#chat-rows p").last().text().indexOf("[Console]") > -1) {
            amount++;
          }
          $("#chat-rows p").last().remove();
        }
        break;
      case 99:
        addChat(msg, offset);
        break;
    }
  }

  function addChat(view, offset) {
    function getString() {
      var text = '',
        char;
      while ((char = view.getUint16(offset, true)) != 0) {
        offset += 2;
        text += String.fromCharCode(char);
      }
      offset += 2;
      return text;
    }
    var pID = -1;
    if (view.getUint8(offset++) == 2) {
      pID = view.getUint32(offset, true);
      offset += 4;
    }
    var r = view.getUint8(offset++),
      g = view.getUint8(offset++),
      b = view.getUint8(offset++),
      color = (r << 16 | g << 8 | b).toString(16);
    while (color.length < 6) {
      color = '0' + color;
    }
    color = '#' + color;
    var name = getString();
    var message = getString();
    var string = "";
    var clickable = 'style="pointer-events:all;cursor: pointer;" onclick="showPlayerMenu(' + pID + ', \'' + name + '\');"';
    if (blocklist.indexOf(pID) > -1) {
      return;
    }
    if (name.toLowerCase().indexOf("console") > -1 || name.toLowerCase().indexOf("admin") > -1 || name.toLowerCase().indexOf("[owner]") > -1 || name.toLowerCase().indexOf("mod") > -1) {
      string = '<p style="height: initial;max-height: none !important;" id="mod_chat">' + name + " : " + message + '</p>';
    } else {
      name = filterXSS(name).replace(/<(?:.|\n)*?>/gm, '');
      message = filterXSS(message).replace(/<(?:.|\n)*?>/gm, '');
      string = '<p><font ' + clickable + ' title="' + pID + '" color="' + color + '">' + name + '</font><font ' + "" + ' title="' + pID + '" color="black">' + ' :</font> ' + message + '</p>';
    }
    if (message.toLowerCase().indexOf("welcome to") > -1 && name.toLowerCase().indexOf("console") > -1) {
      var welcome = '<p><b><font style="font-size: 23px;font-weight:700;" color="' + "#00D8C0" + '">' + "Welcome to Germs.io" + '!</font></b></p>';
      welcome += '<p style="height: initial;max-height: none !important;font-size: 21px;font-weight:700;color:#2C2F33;"><b>' + "Check out our <a style='color: #7289DA;pointer-events: all !important;' href='https://discord.gg/germs' target='_blank' >Discord Server</a>" + '!</b></p>';
      string = welcome;
    }
    if (message.toLowerCase().indexOf("server restart") > -1 && name.toLowerCase().indexOf("[console]") > -1) {
      var msg = '<p><b><font style="font-size: 23px;font-weight:700;" color="' + "red" + '">' + "Server restart in 5 minutes" + '!</b></p>';
      string = msg;
    }
    if ($("#chat-rows p").length > 15) {
      $("#chat-rows p").first().remove();
      document.getElementById('chat-rows').innerHTML += string;
    } else {
      document.getElementById('chat-rows').innerHTML += string;
    }
    $("#mod_chat font").each(function() {
      $(this).css({
        "height": "initial",
        "text-overflow": "initial",
        "max-width": "none"
      });
    });
  }

  function updateNodes(view, offset) {
    function getString() {
      var text = '',
        char;
      while ((char = view.getUint16(offset, true)) != 0) {
        offset += 2;
        text += String.fromCharCode(char);
      }
      offset += 2;
      return text;
    }

    function getSkin() {
      var text = '',
        char;
      while ((char = view.getUint8(offset, true)) != 0) {
        offset++;
        text += String.fromCharCode(char);
      }
      offset++;
      return text;
    }
    timestamp = +new Date;
    var code = Math.random();
    ua = false;
    var queueLength = view.getUint16(offset, true);
    offset += 2;
    var i;
    for (i = 0; i < queueLength; ++i) {
      var killer = nodes[view.getUint32(offset, true)],
        killedNode = nodes[view.getUint32(offset + 4, true)];
      offset += 8;
      if (killer && killedNode) {
        if (nodesOnScreen.indexOf(killedNode.id) > -1) {
          lastKilled = killer.id;
        }
        killedNode.destroy();
        killedNode.ox = killedNode.x;
        killedNode.oy = killedNode.y;
        killedNode.oSize = killedNode.size;
        killedNode.nx = killer.x;
        killedNode.ny = killer.y;
        killedNode.nSize = killedNode.size;
        killedNode.updateTime = timestamp;
        updateStats(killer, killedNode);
      }
    }
    for (var i = 0;; i++) {
      var nodeid = view.getUint32(offset, true);
      offset += 4;
      if (0 == nodeid) break;
      if (newProtocol) {
        var posX = view.getInt32(offset, true);
        offset += 4;
        var posY = view.getInt32(offset, true);
        offset += 4;
      } else {
        var posX = view.getInt16(offset, true);
        offset += 2;
        var posY = view.getInt16(offset, true);
        offset += 2;
      }
      var size = view.getInt16(offset, true);
      offset += 2;
      for (var r = view.getUint8(offset++), g = view.getUint8(offset++), b = view.getUint8(offset++), color = (r << 16 | g << 8 | b).toString(16); 6 > color.length;) color = "0" + color;
      var flagSkin = false,
        skin = "";
      var colorstr = "#" + color;
      if (newProtocol) {
        var flags = view.getUint8(offset++),
          flagVirus = !!(flags & 1),
          flagAgitated = !!(flags & 16);
        flags & 2 && (offset += 4 + view.getUInt32(offset, true));
        flags & 4 && (flagSkin = true);
        if (flagSkin) {
          skin = getSkin();
        }
      } else {
        var flags = view.getUint8(offset++),
          flagVirus = !!(flags & 1),
          flagAgitated = !!(flags & 16);
        flags & 2 && (offset += 4);
        flags & 4 && (offset += 8);
        flags & 8 && (offset += 16);
      }
      name = getString();
      var node = null;
      if (nodes.hasOwnProperty(nodeid)) {
        node = nodes[nodeid];
        node.updatePos();
        node.ox = node.x;
        node.oy = node.y;
        node.oSize = node.size;
        node.color = colorstr;
      } else {
        node = new Cell(nodeid, posX, posY, size, colorstr, name, skin);
        nodelist.push(node);
        nodes[nodeid] = node;
        node.ka = posX;
        node.la = posY;
      }
      node.isVirus = flagVirus;
      node.isAgitated = flagAgitated;
      node.nx = posX;
      node.ny = posY;
      node.nSize = size;
      node.updateCode = code;
      node.updateTime = timestamp;
      node.flag = flags;
      if (flagSkin) node.skin = skin;
      name && node.setName(name);
      if (-1 != nodesOnScreen.indexOf(nodeid) && -1 == playerCells.indexOf(node)) {
        playerCells.push(node);
        if (1 == playerCells.length) {
          document.getElementById("overlays").style.display = "none";
          nodeX = node.x;
          nodeY = node.y;
        }
      }
    }
    queueLength = view.getUint32(offset, true);
    offset += 4;
    for (i = 0; i < queueLength; i++) {
      var nodeId = view.getUint32(offset, true);
      offset += 4;
      node = nodes[nodeId];
      null != node && node.destroy();
    }
    if (ua && playerCells.length == 0) {
      showOverlays(false);
      if (lastKilled != -1) {
        follow = lastKilled;
      }
    }
  }

  function sendMouseMove() {
    clearInterval(mouseInterval);
    if (wsIsOpen()) {
      var msg = rawMouseX - canvasWidth / 2;
      var b = rawMouseY - canvasHeight / 2;
      if (64 <= msg * msg + b * b && !(.01 > Math.abs(oldX - X) && .01 > Math.abs(oldY - Y))) {
        oldX = X;
        oldY = Y;
        msg = prepareData(21);
        msg.setUint8(0, 16);
        msg.setFloat64(1, X, true);
        msg.setFloat64(9, Y, true);
        msg.setUint32(17, 0, true);
        wsSend(msg);
      }
      if (spam) {
        sendUint8(21);
      }
    }
    mouseInterval = setInterval(sendMouseMove, 50);
  }

  function isPlaying(audelem) {
    return !audelem.paused;
  }

  function sendNickName() {
    if (wsIsOpen() && null != userNickName) {
      var msg = prepareData(1 + 2 * userNickName.length);
      msg.setUint8(0, 0);
      for (var i = 0; i < userNickName.length; ++i) msg.setUint16(1 + 2 * i, userNickName.charCodeAt(i), true);
      wsSend(msg);
      hideOverlays();
    }
  }

  function sendChat(str) {
    if (wsIsOpen() && (str.length < 200) && (str.length > 0)) {
      var msg = prepareData(2 + 2 * str.length);
      var offset = 0;
      msg.setUint8(offset++, 99);
      msg.setUint8(offset++, 0);
      for (var i = 0; i < str.length; ++i) {
        msg.setUint16(offset, str.charCodeAt(i), true);
        offset += 2;
      }
      wsSend(msg);
    }
  }

  function sendAdmin(str) {
    if (wsIsOpen() && (str.length < 200) && (str.length > 0)) {
      var msg = prepareData(2 + 2 * str.length);
      var offset = 0;
      msg.setUint8(offset++, 69);
      msg.setUint8(offset++, 0);
      for (var i = 0; i < str.length; ++i) {
        msg.setUint16(offset, str.charCodeAt(i), true);
        offset += 2;
      }
      wsSend(msg);
    }
  }

  function wsIsOpen() {
    return null != ws && ws.readyState == ws.OPEN;
  }

  function sendUint8(a) {
    if (wsIsOpen()) {
      var msg = prepareData(1);
      msg.setUint8(0, a);
      wsSend(msg)
    }
  }

  function redrawGameScene() {
    if (isActive != false) {
      drawGameScene();
      self.requestAnimationFrame(redrawGameScene);
    }
  }

  function canvasResize() {
    var a = $("#login");
    a.css("transform", "none");
    var b = a.height(),
      d = self.innerHeight;
    0 != b / 2 % 2 && (b++, a.height(b));
    b > d / 1.1 ? a.css("transform", "translate(-50%, -50%) scale(" + d / b / 1.1 + ")") : a.css("transform", "translate(-50%, -50%)");
    var a = $("#skinModal");
    a.css("transform", "none");
    var b = a.height(),
      d = self.innerHeight;
    0 != b / 2 % 2 && (b++, a.height(b));
    b > d / 1.1 ? a.css("transform", "translate(-50%, -50%) scale(" + d / b / 1.1 + ")") : a.css("transform", "translate(-50%, -50%)");
    window.scrollTo(0, 0);
    canvasWidth = self.innerWidth;
    canvasHeight = self.innerHeight;
    nCanvas.width = canvasWidth;
    nCanvas.height = canvasHeight;
  }

  function viewRange() {
    var ratio;
    ratio = Math.max(canvasHeight / 1080, canvasWidth / 1920);
    return ratio * zoom;
  }

  function calcViewZoom() {
    if (0 != playerCells.length) {
      for (var newViewZoom = 0, i = 0; i < playerCells.length; i++) newViewZoom += playerCells[i].size;
      newViewZoom = Math.pow(Math.min(64 / newViewZoom, 1), .4) * viewRange();
      viewZoom = (9 * viewZoom + newViewZoom) / 10
    }
  }
  var fps = 60;
  window.countFPS = (function() {
    var lastLoop = (new Date()).getMilliseconds();
    var count = 1;
    var fps = 0;
    return function() {
      var currentLoop = (new Date()).getMilliseconds();
      if (lastLoop > currentLoop) {
        fps = count;
        count = 1;
      } else {
        count += 1;
      }
      lastLoop = currentLoop;
      return fps;
    };
  }());

  function lerp(v0, v1, t) {
    return v0 * (1 - t) + v1 * t
  }

  function drawGameScene() {
    fps = countFPS();
    var a, oldtime = Date.now();
    ++cb;
    timestamp = oldtime;
    if (0 < playerCells.length) {
      calcViewZoom();
      var c = a = 0;
      for (var d = 0; d < playerCells.length; d++) {
        playerCells[d].updatePos();
        a += playerCells[d].x / playerCells.length;
        c += playerCells[d].y / playerCells.length;
      }
      posX = a;
      posY = c;
      posSize = viewZoom;
      nodeX = (nodeX + a) / 2;
      nodeY = (nodeY + c) / 2;
      var a = cameraX - nodeX;
      var b = cameraY - nodeY;
      var c = Math.sqrt(a * a + b * b);
      if (c > 1000) {
        cameraX = nodeX;
        cameraY = nodeY;
      } else {
        cameraX = lerp(cameraX, nodeX, 0.3);
        cameraY = lerp(cameraY, nodeY, 0.3);
      }
    } else {
      if (follow != -1) {
        var killer = nodes[follow];
        if (killer) {
          nodeX = killer.x;
          nodeY = killer.y;
          cameraX = lerp(cameraX, nodeX, 0.1);
          cameraY = lerp(cameraY, nodeY, 0.1);
        } else {
          follow = -1;
          lastKilled = -1;
        }
      } else {
        nodeX = (29 * nodeX + posX) / 30;
        nodeY = (29 * nodeY + posY) / 30;
        viewZoom = (9 * viewZoom + posSize * viewRange()) / 10;
        cameraX = nodeX;
        cameraY = nodeY;
      }
    }
    buildQTree();
    mouseCoordinateChange();
    if (xa) {
      ctx.globalAlpha = .05;
      if (showDarkTheme) {
        ctx.fillStyle = '#111111';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      } else {
        ctx.fillStyle = '#F2FBFF';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      }
      ctx.globalAlpha = 1;
    } else {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawGrid();
    }
    nodelist.sort(function(a, b) {
      return a.size == b.size ? a.id - b.id : a.size - b.size;
    });
    ctx.save();
    ctx.translate(canvasWidth / 2, canvasHeight / 2);
    ctx.scale(viewZoom, viewZoom);
    ctx.translate(-cameraX, -cameraY);
    if (drawLine && playerCells.length > 0) {
      drawLineX = (3 * drawLineX + lineX) / 4;
      drawLineY = (3 * drawLineY + lineY) / 4;
      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = playerCells[0].color;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.globalAlpha = .5;
      ctx.beginPath();
      for (d = 0; d < playerCells.length; d++) {
        ctx.moveTo(playerCells[d].x, playerCells[d].y);
        ctx.lineTo(drawLineX, drawLineY);
      }
      ctx.stroke();
      ctx.restore()
    }
    for (d = 0; d < Cells.length; d++) Cells[d].drawOneCell(ctx);
    for (d = 0; d < nodelist.length; d++) nodelist[d].drawOneCell(ctx);
    ctx.strokeStyle = '#00D1DF';
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    var extraAmount = 0;
    ctx.moveTo(leftPos - extraAmount, topPos - extraAmount);
    ctx.lineTo(rightPos + extraAmount, topPos - extraAmount);
    ctx.lineTo(rightPos + extraAmount, bottomPos + extraAmount);
    ctx.lineTo(leftPos - extraAmount, bottomPos + extraAmount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    lbCanvas && lbCanvas.width && ctx.drawImage(lbCanvas, canvasWidth - lbCanvas.width - 10, 10);
    var mass = calcUserScore();
    userScore = Math.max(userScore, mass);
    if (0 != userScore) {
      if (null == scoreText) {
        scoreText = new UText(24, '#FFFFFF');
      }
      var boxOpacity = .25;
      scoreText.setValue("Score: " + ~~(userScore / 100));
      c = scoreText.render();
      w = c.width;
      ctx.globalAlpha = boxOpacity;
      ctx.fillStyle = "#000000";
      ctx.fillRect(10, 10, w + 10, 34);
      ctx.globalAlpha = 1;
      ctx.drawImage(c, 15, 15);
      scoreText.setValue("Mass: " + ~~(mass / 100));
      c = scoreText.render();
      w = c.width;
      ctx.fillStyle = "rgba(0,0,0, " + boxOpacity;
      ctx.fillRect(10, 50, w + 10, 34);
      ctx.drawImage(c, 15, 55);
    }
    if (isMobile) {
      if (splitIcon.width) {
        var size = ~~(canvasWidth / 7);
        ctx.drawImage(splitIcon, canvasWidth - size, canvasHeight - size, size, size);
      }
      if (ejectIcon.width) {
        var size = ~~(canvasWidth / 7);
        ctx.drawImage(ejectIcon, canvasWidth - size, canvasHeight - 2 * size - 10, size, size);
      }
    } else {
      drawMap();
    }
    var deltatime = Date.now() - oldtime;
    deltatime > 1E3 / 60 ? z -= .01 : deltatime < 1E3 / 65 && (z += .01);
    .4 > z && (z = .4);
    1 < z && (z = 1)
  }

  function showRemaining(end) {
    var _second = 1000;
    var _minute = _second * 60;
    var _hour = _minute * 60;
    var _day = _hour * 24;
    var now = new Date();
    end = new Date(end.getTime() - 1 * 60000);
    var distance = end - now;
    var days = Math.floor(distance / _day);
    var hours = Math.floor((distance % _day) / _hour);
    var minutes = Math.floor((distance % _hour) / _minute);
    var seconds = Math.floor((distance % _minute) / _second);
    var string = "";
    if (hours > 0) string += hours + 'h ';
    string += minutes + 'm ';
    string += seconds + 's ';
    var color = "green";
    if (hours < 1) {
      color = "orange";
    }
    if (hours < 1 && minutes < 15) {
      color = "red";
    }
    if ((hours + minutes + seconds) < 0) {
      string = "Restarting Soon!";
    }
    return {
      Text: string,
      Color: color
    };
  }

  function drawMap() {
    if (!(lbCanvas && lbCanvas.width) || !map || hasOverlay) return;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,.25)";
    var size = isMobile ? 150 : 200;
    ctx.lineWidth = 1.5;
    var mapX = canvasWidth - size - 10;
    var mapY = canvasHeight - size - 10;
    var centerX = canvasWidth - (size / 2) - 10;
    var centerY = canvasHeight - (size / 2) - 10;
    ctx.rect(mapX, mapY, size, size);
    ctx.fill();
    ctx.font = "900 15px Roboto";
    ctx.fillStyle = (showDarkTheme) ? "rgba(255, 255, 255, .9)" : "rgba(0,0,0,.45)";
    var displayfps = "FPS: ";
    ctx.fillText(displayfps, mapX, mapY - 5);
    ctx.fillStyle = (fps >= 40) ? "green" : ((fps >= 20)) ? "orange" : "red";
    ctx.fillText(~~fps, mapX + ctx.measureText(displayfps).width, mapY - 5);
    var fpsWidth = ctx.measureText(displayfps + ~~fps).width;
    ctx.fillStyle = (showDarkTheme) ? "rgba(255, 255, 255, .9)" : "rgba(0,0,0,.45)";
    var x = "X: " + ~~nodeX + ", ";
    ctx.fillText(x, mapX + fpsWidth + 5, mapY - 5);
    ctx.fillText("Y: " + ~~nodeY, mapX + fpsWidth + 5 + ctx.measureText(x).width, mapY - 5);
    if (restart != "") {
      ctx.font = "900 15px Roboto";
      ctx.fillStyle = (showDarkTheme) ? "rgba(255, 255, 255, .9)" : "rgba(0,0,0,.45)";
      var restarttext = "Restart: ";
      ctx.fillText(restarttext, mapX, mapY - 25);
      ctx.font = "700 15px Roboto";
      var left = showRemaining(new Date(restart));
      ctx.fillStyle = left.Color;
      ctx.fillText(left.Text, mapX + ctx.measureText(restarttext).width, mapY - 25);
    }
    ctx.closePath();
    ctx.beginPath();
    ctx.lineWidth = 1.25;
    var radiusX = (Math.abs(rightPos) + Math.abs(leftPos)) / 2;
    var radiusY = (Math.abs(topPos) + Math.abs(bottomPos)) / 2;
    var posX = (nodeX / radiusX) * size / 2 + centerX;
    var posY = (nodeY / radiusY) * size / 2 + centerY;
    var bw = bh = size;
    var insideX = -1;
    var insideY = -1;
    for (var x = 0; x <= bw; x += 40) {
      if (x != bw) {
        var ix = 0.5 + x + mapX;
        var iy = mapY;
        if (insideBox(ix, iy, ix + 40, iy + bh, posX, posY)) {
          insideX = ix;
        }
        if (x == 0) continue;
        ctx.moveTo(0.5 + x + mapX, mapY);
        ctx.lineTo(0.5 + x + mapX, bh + mapY);
      }
      ctx.fillStyle = "white";
      ctx.font = "900 18px Ubuntu";
      ctx.textAlign = "center";
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.35;
      for (var i = 0; i < 5; i++) {
        ctx.fillText(String.fromCharCode(i + 65) + x / 40, (0.5 + x + mapX) - 20, mapY + 25.5 + (i * 40));
      }
    }
    for (var y = 0; y <= bh; y += 40) {
      if (y != bh) {
        var ix = mapX;
        var iy = 0.5 + y + mapY;
        if (insideBox(ix, iy, ix + bw, iy + 40, posX, posY)) {
          insideY = iy;
        }
        if (y == 0) continue;
        ctx.moveTo(mapX, 0.5 + y + mapY);
        ctx.lineTo(bw + mapX, 0.5 + y + mapY);
      }
    }
    if (playerCells.length > 0 && insideX > -1 && insideY > -1) {
      ctx.fillStyle = "#ccff00";
      ctx.globalAlpha = 0.3;
      ctx.fillRect(insideX, insideY, 40, 40);
    }
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(255,255,255,.2)";
    ctx.stroke();
    ctx.closePath();
    for (var i = 0; i < playerCells.length; i++) {
      var player = playerCells[i];
      var radiusX = (Math.abs(rightPos) + Math.abs(leftPos)) / 2;
      var radiusY = (Math.abs(topPos) + Math.abs(bottomPos)) / 2;
      var x = (player.ox / radiusX);
      var y = (player.oy / radiusY);
      x = x * size / 2 + centerX;
      y = y * size / 2 + centerY;
      var mass = Math.max(2, player.size / (size / 2));
      ctx.fillStyle = player.color;
      if (i == 0) {
        ctx.font = "bold " + (14 + mass) + "px Ubuntu";
        var measure = ctx.measureText(player.name);
        ctx.strokestyle = "black";
      }
      ctx.beginPath();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 1;
      ctx.arc(x, y, mass, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
    }
    ctx.restore();
  }

  function insideBox(ix, iy, ax, ay, x, y) {
    if (ix <= x && x <= ax && iy <= y && y <= ay) {
      return true;
    }
    return false;
  }

  function drawGrid() {
    var a = canvasWidth / viewZoom,
      b = canvasHeight / viewZoom;
    ctx.fillStyle = showDarkTheme ? "#121212" : "#F2FBFF";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    if (!grid) return;
    ctx.save();
    ctx.strokeStyle = "#AAAAAA";
    ctx.globalAlpha = .2;
    ctx.lineWidth = 1;
    ctx.scale(viewZoom, viewZoom);
    ctx.beginPath();
    for (var c = -.5 + (-cameraX + a / 2) % 50; c < a; c += 50) {
      ctx.moveTo(c, 0);
      ctx.lineTo(c, b);
    }
    ctx.stroke();
    ctx.beginPath();
    for (c = -.5 + (-cameraY + b / 2) % 50; c < b; c += 50) {
      ctx.moveTo(0, c);
      ctx.lineTo(a, c);
    }
    ctx.stroke();
    ctx.restore()
  }

  function calcUserScore() {
    for (var score = 0, i = 0; i < playerCells.length; i++) score += playerCells[i].nSize * playerCells[i].nSize;
    return score;
  }

  function onLeaderBoard() {
    if (null != leaderBoard) {
      for (var a = 0; a < leaderBoard.length; ++a)
        if (-1 != nodesOnScreen.indexOf(leaderBoard[a].id)) return a + 1;
      return 0;
    }
    return 0;
  }
  var interval = setInterval(function() {
    if (0 != onLeaderBoard()) timeLeader++;
  }, 1050);

  function drawLeaderBoard() {
    lbCanvas = null;
    if (null != teamScores || 0 != leaderBoard.length)
      if (null != teamScores || showName || !showName) {
        lbCanvas = document.createElement("canvas");
        var ctx = lbCanvas.getContext("2d"),
          boardLength = 60;
        if (0 == playerCells.length) leaderBoard.splice(-1, 1);
        boardLength = null == teamScores ? boardLength + 24 * leaderBoard.length : boardLength + 180;
        var scaleFactor = Math.min(200, .3 * canvasWidth) / 200;
        lbCanvas.width = 200 * scaleFactor;
        lbCanvas.height = boardLength * scaleFactor + 50;
        ctx.scale(scaleFactor, scaleFactor);
        ctx.globalAlpha = .25;
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, 200, boardLength);
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#FFFFFF";
        var c = "Leaderboard";
        ctx.font = "30px Ubuntu";
        ctx.fillText(c, 100 - ctx.measureText(c).width / 2, 40);
        var b;
        if (null == teamScores) {
          for (ctx.font = "20px Ubuntu", b = 0; b < leaderBoard.length; ++b) {
            c = leaderBoard[b].name || "An unnamed cell";
            if (-1 != nodesOnScreen.indexOf(leaderBoard[b].id)) {
              if (topPosition >= (b + 1) || topPosition == 0) {
                topPosition = leaderBoard[b].rank + 1;
              }
              ctx.fillStyle = "#ccff00";
              if (!noRanking) {
                c = leaderBoard[b].rank + 1 + ". " + c;
              }
              ctx.fillText(c, 100 - ctx.measureText(c).width / 2, 70 + 24 * b);
            } else {
              ctx.fillStyle = "#FFFFFF";
              if (!noRanking) {
                c = leaderBoard[b].rank + 1 + ". " + c;
              }
              ctx.fillText(c, 100 - ctx.measureText(c).width / 2, 70 + 24 * b);
            }
          }
        } else {
          ctx.beginPath();
          for (b = c = 0; b < teamScores.length; ++b) {
            var d = c + teamScores[b] * Math.PI * 2;
            ctx.fillStyle = teamColor[b + 1];
            ctx.moveTo(100, 140);
            ctx.arc(100, 140, 80, c, d, false);
            c = d
          }
          ctx.fill();
        }
      }
  }

  function Cell(uid, ux, uy, usize, ucolor, uname, skin) {
    this.id = uid;
    this.ox = this.x = ux;
    this.oy = this.y = uy;
    this.oSize = this.size = usize;
    this.color = ucolor;
    this.points = [];
    this.pointsAcc = [];
    this.createPoints();
    this.setName(uname)
    this.skin = skin;
  }

  function UText(usize, ucolor, ustroke, ustrokecolor) {
    usize && (this._size = usize);
    ucolor && (this._color = ucolor);
    this._stroke = !!ustroke;
    ustrokecolor && (this._strokeColor = ustrokecolor)
  }
  var localProtocol = self.location.protocol,
    localProtocolHttps = "https:" == localProtocol;
  var nCanvas, ctx, mainCanvas, lbCanvas, chatCanvas, canvasWidth, canvasHeight, qTree = null,
    ws = null,
    mouseInterval, loaded = false,
    follow = -1,
    lastKilled = -1,
    nodeX = 0,
    nodeY = 0,
    cameraX = 0,
    cameraY = 0,
    smoothRender = .3,
    debug = false,
    nodesOnScreen = [],
    playerCells = [],
    nodes = {},
    nodelist = [],
    Cells = [],
    leaderBoard = [],
    chatBoard = [],
    rawMouseX = 0,
    rawMouseY = 0,
    X = -1,
    Y = -1,
    cb = 0,
    timestamp = 0,
    userNickName = null,
    leftPos = 0,
    topPos = 0,
    rightPos = 1E4,
    bottomPos = 1E4,
    viewZoom = 1,
    w = null,
    showSkin = true,
    showName = true,
    showColor = false,
    ua = false,
    userScore = 0,
    showDarkTheme = false,
    showMass = false,
    posX = nodeX = ~~((leftPos + rightPos) / 2),
    posY = nodeY = ~~((topPos + bottomPos) / 2),
    posSize = 1,
    gameMode = "",
    teamScores = null,
    ma = false,
    hasOverlay = true,
    drawLine = false,
    foodEaten = 0,
    timeAlive = Date.now(),
    timeLeader = null,
    topPosition = 0,
    cellsEaten = 0,
    lineX = 0,
    lineY = 0,
    drawLineX = 0,
    drawLineY = 0,
    Ra = 0,
    teamColor = ["#333333", "#FF3333", "#33FF33", "#3333FF"],
    xa = false,
    zoom = 1,
    sendSkin = null,
    isTouchStart = "ontouchstart" in self && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    noRanking = false;
  self.isSpectating = false;
  self.setLoaded = function(arg) {
    loaded = arg;
  };
  self.setSkin = function(arg) {
    if (arg != "None") {
      $("#selectedSkin").text(arg);
      $("#nick").css("padding-left", $("#selectedSkin").width() + 11 + "px");
      sendSkin = arg;
    } else {
      $("#selectedSkin").text("");
      $("#nick").css("padding-left", 11 + "px");
      sendSkin = "";
    }
    createCookie('_skin', arg, 7);
    $("#selector").fadeOut('fast');
    $('.skinList > li').hide();
  };
  self.setNick = function(arg) {
    userNickName = arg;
    createCookie('_nom', arg, 7);
    if (sendSkin != null) {
      userNickName = "<" + sendSkin + ">" + userNickName;
    }
    sendNickName();
    userScore = 0;
    foodEaten = 0;
    follow = -1;
    lastKilled = -1;
    timeAlive = Date.now();
    timeLeader = null;
    topPosition = 0;
    cellsEaten = 0;
  };
  self.setSkins = function(arg) {
    showSkin = arg
  };
  self.setNames = function(arg) {
    showName = arg
  };
  self.setDarkTheme = function(arg) {
    showDarkTheme = arg;
    updateChatColor();
  };
  self.setColors = function(arg) {
    showColor = arg
  };
  self.setShowMass = function(arg) {
    showMass = arg
  };
  self.spectate = function() {
    userNickName = null;
    self.isSpectating = true;
    sendUint8(1);
    hideOverlays()
  };
  self.setGameMode = function(arg) {
    if (arg != gameMode) {
      gameMode = arg;
      $("#playBtn").prop('disabled', true);
      next();
    }
  };
  self.setAcid = function(arg) {
    xa = arg
  };
  self.getPartyServer = function() {
    $('#partySelect').hide();
    $('#partyCreate').show();
    $('#createDone').hide();
    $('#createLoad').show();
    $.get("http://party.germs.io:443", function(data, status) {
      var result = JSON.parse(h2(data));
      var hash = "??????";
      var port = -1;
      var lowest = -1;
      var players = 0;
      for (var each in result) {
        var server = result[each];
        var tempHash = server["Name"];
        var tempPort = parseInt(server["Port"]);
        var tempPlayers = parseInt(server["Count"]);
        var limit = parseInt(server["Max"]);
        if (limit > 0 && tempHash.indexOf("5E678") == -1) {
          if (lowest != -1 && (tempPlayers > lowest || tempPlayers >= limit)) {
            continue;
          } else {
            hash = tempHash;
            port = tempPort;
            players = lowest = tempPlayers;
          }
        } else {
          continue;
        }
      }
      if (hash != "??????") {
        $('#createDone').show();
        $('#createLoad').hide();
        window.location.hash = hash;
        $("#partyToken").val("germs.io/#" + hash);
        next(false, [port, players]);
      } else {
        getPartyServer();
      }
    });
  };
  self.setPartyServer = function(d) {
    $('#partySelect').hide();
    $('#partyCreate').hide();
    $('#createDone').hide();
    $('#partyDone').hide();
    $('#createLoad').show();
    $("#joinText").text("Connecting...");
    myHash = (d.indexOf("#") > -1) ? d.split("#")[1] : d;
    $.get("http://party.germs.io:443", function(data, status) {
      var result = JSON.parse(h2(data));
      var hash = "??????";
      var port = -1;
      var lowest = -1;
      var players = 0;
      for (var each in result) {
        var server = result[each];
        var tempHash = server["Name"];
        var tempPort = parseInt(server["Port"]);
        var tempPlayers = parseInt(server["Count"]);
        var limit = parseInt(server["Max"]);
        if (tempPlayers == limit) {
          alert("Server is full.. Joining another!");
          partySelect();
          getPartyServer();
          return;
        }
        if (tempHash.toLowerCase() == myHash.toLowerCase()) {
          hash = tempHash;
          port = tempPort;
          players = tempPlayers;
          lowest = players;
        }
      }
      if (hash != "??????") {
        window.location.hash = hash;
        $("#partyToken").val("germs.io/#" + hash);
        $("#tokenText").text('#' + hash);
        next(false, [port, players]);
        $('#partyDone').show();
        $('#partyEnter').hide();
      } else {
        $("#joinText").text("Invalid Code!");
      }
    });
  };
  self.partySelect = function() {
    $("#partyJoin").hide();
    $("#partyCreate").hide();
    $("#partySelect").show();
    $("#partyDone").hide();
    dest = current = "";
    next(false);
  };
  self.connect = open;

  function updateChatColor() {
    $("#chat-rows").css("color", showDarkTheme ? "white" : "black");
  }

  function timeToString(a) {
    a = ~~a;
    var b = (a % 60).toString();
    a = (~~(a / 60)).toString();
    2 > b.length && (b = "0" + b);
    return a + ":" + b
  }
  Array.prototype.toLowerCase = function() {
    var L = this.length,
      tem;
    while (L) {
      tem = this[--L] || '';
      if (tem.toLowerCase) this[L] = tem.toLowerCase();
    }
    return this;
  }
  var angle = 0;
  var delay = 500,
    oldX = -1,
    oldY = -1,
    Canvas = null,
    z = 1,
    scoreText = null,
    foodEaten = 0,
    follow = -1,
    lastKilled = -1,
    timeAlive = Date.now(),
    loadedSkins = [],
    timeLeader = null,
    topPosition = 0,
    cellsEaten = 0,
    knownNameDict = SETTINGS.SKINS.toLowerCase(),
    knownNameDict_noDisp = [""],
    ib = ["_canvas'blob"];
  Cell.prototype = {
    id: 0,
    points: null,
    pointsAcc: null,
    name: null,
    nameCache: null,
    sizeCache: null,
    x: 0,
    y: 0,
    size: 0,
    ox: 0,
    oy: 0,
    oSize: 0,
    nx: 0,
    ny: 0,
    nSize: 0,
    flag: 0,
    updateTime: 0,
    updateCode: 0,
    drawTime: 0,
    destroyed: false,
    isVirus: false,
    isFood: false,
    isAgitated: false,
    wasSimpleDrawing: true,
    destroy: function() {
      var tmp;
      for (tmp = 0; tmp < nodelist.length; tmp++)
        if (nodelist[tmp] == this) {
          nodelist.splice(tmp, 1);
          break
        }
      delete nodes[this.id];
      tmp = playerCells.indexOf(this);
      if (-1 != tmp) {
        ua = true;
        playerCells.splice(tmp, 1);
      }
      tmp = nodesOnScreen.indexOf(this.id);
      if (-1 != tmp) {
        nodesOnScreen.splice(tmp, 1);
      }
      this.destroyed = true;
      Cells.push(this)
    },
    getNameSize: function() {
      return Math.max(~~(.3 * this.size), 24)
    },
    setName: function(a) {
      if (this.name = a) {
        if (null == this.nameCache) {
          this.nameCache = new UText(this.getNameSize(), "#FFFFFF", true, "#000000");
          this.nameCache.setValue(this.name);
        } else {
          this.nameCache.setSize(this.getNameSize());
          this.nameCache.setValue(this.name);
        }
      }
    },
    createPoints: function() {
      for (var samplenum = this.getNumPoints(); this.points.length > samplenum;) {
        var rand = ~~(Math.random() * this.points.length);
        this.points.splice(rand, 1);
        this.pointsAcc.splice(rand, 1)
      }
      if (0 == this.points.length && 0 < samplenum) {
        this.points.push({
          ref: this,
          size: this.size,
          x: this.x,
          y: this.y
        });
        this.pointsAcc.push(Math.random() - .5);
      }
      while (this.points.length < samplenum) {
        var rand2 = ~~(Math.random() * this.points.length),
          point = this.points[rand2];
        this.points.splice(rand2, 0, {
          ref: this,
          size: point.size,
          x: point.x,
          y: point.y
        });
        this.pointsAcc.splice(rand2, 0, this.pointsAcc[rand2])
      }
    },
    getNumPoints: function() {
      if (0 == this.id) return 16;
      var a = 7;
      if (30 > this.size) a = 5;
      if (this.isVirus) a = 20;
      var b = this.size;
      if (this.size < 32) b *= 0.75;
      if (!this.isVirus) {
        b *= viewZoom;
        b *= z;
      }
      return ~~Math.max(b, a);
    },
    movePoints: function() {
      this.createPoints();
      for (var points = this.points, pointsacc = this.pointsAcc, numpoints = points.length, i = 0; i < numpoints; ++i) {
        var pos1 = pointsacc[(i - 1 + numpoints) % numpoints],
          pos2 = pointsacc[(i + 1) % numpoints];
        pointsacc[i] += (Math.random() - .5) * (this.isAgitated ? 3 : 1);
        pointsacc[i] *= .75;
        10 < pointsacc[i] && (pointsacc[i] = 10); - 10 > pointsacc[i] && (pointsacc[i] = -10);
        pointsacc[i] = (pos1 + pos2 + 8 * pointsacc[i]) / 10
      }
      for (var ref = this, isvirus = this.isVirus ? 0 : (this.id / 1E3 + timestamp / 1E4) % (2 * Math.PI), j = 0; j < numpoints; ++j) {
        var f = points[j].size,
          e = points[(j - 1 + numpoints) % numpoints].size,
          m = points[(j + 1) % numpoints].size;
        if (15 < this.size && null != qTree && 20 < this.size * viewZoom && 0 != this.id) {
          var l = false,
            n = points[j].x,
            q = points[j].y;
          qTree.retrieve2(n - 5, q - 5, 10, 10, function(a) {
            if (a.ref != ref && 25 > (n - a.x) * (n - a.x) + (q - a.y) * (q - a.y)) {
              l = true;
            }
          });
          if (!l && points[j].x < leftPos || points[j].y < topPos || points[j].x > rightPos || points[j].y > bottomPos) {
            l = true;
          }
          if (l) {
            if (0 < pointsacc[j]) {
              (pointsacc[j] = 0);
            }
            pointsacc[j] -= 1;
          }
        }
        f += pointsacc[j];
        0 > f && (f = 0);
        f = this.isAgitated ? (19 * f + this.size) / 20 : (12 * f + this.size) / 13;
        points[j].size = (e + m + 8 * f) / 10;
        e = 2 * Math.PI / numpoints;
        m = this.points[j].size;
        this.isVirus && 0 == j % 2 && (m += 5);
        points[j].x = this.x + Math.cos(e * j + isvirus) * m;
        points[j].y = this.y + Math.sin(e * j + isvirus) * m
      }
    },
    updatePos: function() {
      if (0 == this.id) return 1;
      var a = (timestamp - this.updateTime) / 135;
      a = 0 > a ? 0 : 1 < a ? 1 : a;
      var b = 0 > a ? 0 : 1 < a ? 1 : a;
      var d = (timestamp - this.updateTime) / 120;
      d = 0 > d ? 0 : 1 < d ? 1 : d;
      var z = 0 > d ? 0 : 1 < d ? 1 : d;
      if (this.destroyed && 1 <= b) {
        var c = Cells.indexOf(this); - 1 != c && Cells.splice(c, 1)
      }
      this.x = lerp(this.ox, this.nx, b);
      this.y = lerp(this.oy, this.ny, b);
      this.size = z * (this.nSize - this.oSize) + this.oSize;
      return b;
    },
    shouldRender: function() {
      if (0 == this.id) {
        return true
      } else {
        return !(this.x + this.size + 40 < nodeX - canvasWidth / 2 / viewZoom || this.y + this.size + 40 < nodeY - canvasHeight / 2 / viewZoom || this.x - this.size - 40 > nodeX + canvasWidth / 2 / viewZoom || this.y - this.size - 40 > nodeY + canvasHeight / 2 / viewZoom);
      }
    },
    drawOneCell: function(ctx) {
      if (this.shouldRender()) {
        var b = (0 != this.id && !this.isVirus && !this.isAgitated && smoothRender > viewZoom);
        if (5 > this.getNumPoints()) b = true;
        this.isFood = (!this.isVirus && (this.name == null || this.name.trim() == ""));
        if (this.isFood) b = true;
        if (this.wasSimpleDrawing && !b)
          for (var c = 0; c < this.points.length; c++) this.points[c].size = this.size;
        this.wasSimpleDrawing = b;
        ctx.save();
        this.drawTime = timestamp;
        c = this.updatePos();
        this.destroyed && (ctx.globalAlpha *= 1 - c);
        ctx.lineWidth = 12;
        ctx.lineCap = "round";
        ctx.lineJoin = this.isVirus ? "miter" : "round";
        if (showColor) {
          ctx.fillStyle = "#FFFFFF";
          ctx.strokeStyle = "#AAAAAA";
        } else {
          ctx.fillStyle = this.color;
          ctx.strokeStyle = this.color;
        }
        if (b) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI, false);
        } else {
          this.movePoints();
          ctx.beginPath();
          var d = this.getNumPoints();
          ctx.moveTo(this.points[0].x, this.points[0].y);
          for (c = 1; c <= d; ++c) {
            var e = c % d;
            ctx.lineTo(this.points[e].x, this.points[e].y)
          }
        }
        ctx.globalAlpha = 1;
        ctx.closePath();
        var skinName = this.name.toLowerCase();
        if (this.skin != "") {
          skinName = this.skin.substr(1).toLowerCase();
        }
        if (!this.isAgitated && showSkin && ':teams' != gameMode) {
          if (knownNameDict.indexOf(skinName) > -1) {
            if (!skins.hasOwnProperty(skinName)) {
              skins[skinName] = new Image;
              skins[skinName].src = "http://germs.io/skins/" + skinName + '.png?v=' + SETTINGS.HASH;
            }
            if (0 != skins[skinName].width && skins[skinName].complete) {
              c = skins[skinName];
            } else {
              c = null;
            }
          } else {
            c = null;
          }
        } else {
          c = null;
        }
        c = (e = c) ? (-1 != ib.indexOf(skinName)) : false;
        b || ctx.stroke();
        ctx.fill();
        if (!(null == e || c)) {
          ctx.save();
          ctx.clip();
          ctx.drawImage(e, this.x - this.size, this.y - this.size, 2 * this.size, 2 * this.size);
          ctx.restore();
        }
        if (bubblemode) {
          ctx.save();
          ctx.clip();
          ctx.drawImage(bubble, this.x - this.size, this.y - this.size, 2 * this.size, 2 * this.size);
          ctx.restore();
        }
        if ((showColor || 15 < this.size) && !b) {
          ctx.strokeStyle = '#000000';
          ctx.globalAlpha = .05;
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
        c = -1 != playerCells.indexOf(this);
        var ncache;
        if (0 != this.id) {
          var b = ~~this.y;
          if ((showName || c) && this.name && this.nameCache && (null == e || -1 == knownNameDict_noDisp.indexOf(skinName))) {
            ncache = this.nameCache;
            ncache.setValue(this.name);
            ncache.setSize(this.getNameSize());
            var ratio = Math.ceil(10 * viewZoom) / 10;
            ncache.setScale(ratio);
            var rnchache = ncache.render(),
              m = ~~(rnchache.width / ratio),
              h = ~~(rnchache.height / ratio);
            ctx.drawImage(rnchache, ~~this.x - ~~(m / 2), b - ~~(h / 2), m, h);
            b += rnchache.height / 2 / ratio + 4
          }
          if (showMass && (c || 0 == playerCells.length && (!this.isVirus || this.isAgitated) && 20 < this.size)) {
            if (null == this.sizeCache) {
              this.sizeCache = new UText(this.getNameSize() / 2, "#FFFFFF", true, "#000000")
            }
            c = this.sizeCache;
            c.setSize(this.getNameSize() / 2);
            c.setValue(~~(this.size * this.size / 100));
            ratio = Math.ceil(10 * viewZoom) / 10;
            c.setScale(ratio);
            e = c.render();
            m = ~~(e.width / ratio);
            h = ~~(e.height / ratio);
            ctx.drawImage(e, ~~this.x - ~~(m / 2), b - ~~(h / 2), m, h);
          }
        }
        ctx.restore()
      }
    }
  };
  UText.prototype = {
    _value: "",
    _color: "#000000",
    _stroke: false,
    _strokeColor: "#000000",
    _size: 16,
    _canvas: null,
    _ctx: null,
    _dirty: false,
    _scale: 1,
    setSize: function(a) {
      if (this._size != a) {
        this._size = a;
        this._dirty = true;
      }
    },
    setScale: function(a) {
      if (this._scale != a) {
        this._scale = a;
        this._dirty = true;
      }
    },
    setStrokeColor: function(a) {
      if (this._strokeColor != a) {
        this._strokeColor = a;
        this._dirty = true;
      }
    },
    setValue: function(a) {
      if (a != this._value) {
        this._value = a;
        this._dirty = true;
      }
    },
    render: function() {
      if (null == this._canvas) {
        this._canvas = document.createElement("canvas");
        this._ctx = this._canvas.getContext("2d");
      }
      if (this._dirty) {
        this._dirty = false;
        var canvas = this._canvas,
          ctx = this._ctx,
          value = this._value,
          scale = this._scale,
          fontsize = this._size,
          font = "900 " + fontsize + 'px Ubuntu,Arial';
        ctx.font = font;
        var h = ~~(.2 * fontsize);
        canvas.width = (ctx.measureText(value).width + 6) * scale;
        canvas.height = (fontsize + h) * scale;
        ctx.font = font;
        ctx.scale(scale, scale);
        ctx.lineWidth = Math.max(fontsize * 0.08, 3);
        ctx.strokeStyle = this._strokeColor;
        ctx.fillStyle = this._color;
        this._stroke && ctx.strokeText(value, 3, fontsize - h / 2);
        ctx.fillText(value, 3, fontsize - h / 2);
      }
      return this._canvas
    },
    getWidth: function() {
      return (ctx.measureText(this._value).width + 6);
    }
  };
  Date.now || (Date.now = function() {
    return (new Date).getTime()
  });
  var Quad = {
    init: function(args) {
      function Node(x, y, w, h, depth) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.depth = depth;
        this.items = [];
        this.nodes = []
      }
      var c = args.maxChildren || 2,
        d = args.maxDepth || 4;
      Node.prototype = {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        depth: 0,
        items: null,
        nodes: null,
        exists: function(selector) {
          for (var i = 0; i < this.items.length; ++i) {
            var item = this.items[i];
            if (item.x >= selector.x && item.y >= selector.y && item.x < selector.x + selector.w && item.y < selector.y + selector.h) return true
          }
          if (0 != this.nodes.length) {
            var self = this;
            return this.findOverlappingNodes(selector, function(dir) {
              return self.nodes[dir].exists(selector)
            })
          }
          return false;
        },
        retrieve: function(item, callback) {
          for (var i = 0; i < this.items.length; ++i) callback(this.items[i]);
          if (0 != this.nodes.length) {
            var self = this;
            this.findOverlappingNodes(item, function(dir) {
              self.nodes[dir].retrieve(item, callback)
            })
          }
        },
        insert: function(a) {
          if (0 != this.nodes.length) {
            this.nodes[this.findInsertNode(a)].insert(a);
          } else {
            if (this.items.length >= c && this.depth < d) {
              this.devide();
              this.nodes[this.findInsertNode(a)].insert(a);
            } else {
              this.items.push(a);
            }
          }
        },
        findInsertNode: function(a) {
          return a.x < this.x + this.w / 2 ? a.y < this.y + this.h / 2 ? 0 : 2 : a.y < this.y + this.h / 2 ? 1 : 3
        },
        findOverlappingNodes: function(a, b) {
          return a.x < this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(0) || a.y >= this.y + this.h / 2 && b(2)) || a.x >= this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(1) || a.y >= this.y + this.h / 2 && b(3)) ? true : false
        },
        devide: function() {
          var a = this.depth + 1,
            c = this.w / 2,
            d = this.h / 2;
          this.nodes.push(new Node(this.x, this.y, c, d, a));
          this.nodes.push(new Node(this.x + c, this.y, c, d, a));
          this.nodes.push(new Node(this.x, this.y + d, c, d, a));
          this.nodes.push(new Node(this.x + c, this.y + d, c, d, a));
          a = this.items;
          this.items = [];
          for (c = 0; c < a.length; c++) this.insert(a[c])
        },
        clear: function() {
          for (var a = 0; a < this.nodes.length; a++) this.nodes[a].clear();
          this.items.length = 0;
          this.nodes.length = 0
        }
      };
      var internalSelector = {
        x: 0,
        y: 0,
        w: 0,
        h: 0
      };
      return {
        root: new Node(args.minX, args.minY, args.maxX - args.minX, args.maxY - args.minY, 0),
        insert: function(a) {
          this.root.insert(a)
        },
        retrieve: function(a, b) {
          this.root.retrieve(a, b)
        },
        retrieve2: function(a, b, c, d, callback) {
          internalSelector.x = a;
          internalSelector.y = b;
          internalSelector.w = c;
          internalSelector.h = d;
          this.root.retrieve(internalSelector, callback)
        },
        exists: function(a) {
          return this.root.exists(a)
        },
        clear: function() {
          this.root.clear()
        }
      }
    }
  };
  self.onload = init
})(window, window.jQuery);
